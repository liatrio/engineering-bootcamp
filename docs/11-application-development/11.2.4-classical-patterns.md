---
docs/11-application-development/11.2.4-classical-patterns.md:
  category: Software Development
  estReadingMinutes: 45
  exercises:
    -
      name: Identify Classical Patterns in Production Code
      description: Analyze a production codebase of your choice to identify Strategy, Factory, Observer, and Decorator patterns in use.
      estMinutes: 90
      technologies:
      - Design Patterns
      - Python
      - Go
      - TypeScript
---
# Classical Gang of Four Patterns

The Gang of Four (GoF) design patterns, documented in the seminal 1994 book "Design Patterns: Elements of Reusable Object-Oriented Software," catalog 23 design patterns that have become fundamental to software engineering. While all 23 patterns are valuable, this section focuses on four patterns that directly embody SOLID principles and are frequently encountered in production codebases.

## Why These Four Patterns?

We've selected these patterns based on three criteria:

1. **Direct SOLID connections**: Each pattern explicitly demonstrates one or more SOLID principles in action
2. **Practical relevance**: These patterns appear frequently in modern enterprise applications
3. **Language agnostic**: They translate naturally across Python, Go, TypeScript, and other languages

The patterns we'll cover:

- **Strategy Pattern** (Behavioral) - Swappable algorithms demonstrating Open/Closed Principle
- **Factory Pattern** (Creational) - Object creation abstraction demonstrating Dependency Inversion Principle  
- **Observer Pattern** (Behavioral) - Event-driven communication for loosely coupled systems
- **Decorator Pattern** (Structural) - Dynamic behavior extension demonstrating Open/Closed Principle

## Pattern Organization

The Gang of Four organized their 23 patterns into three categories based on their primary purpose:

### Creational Patterns

**Purpose**: Control object creation mechanisms to increase flexibility and reuse.

Examples include Factory Method, Abstract Factory, Builder, Singleton, and Prototype. These patterns abstract the instantiation process, making systems independent of how objects are created, composed, and represented.

**In this section**: Factory Pattern

### Behavioral Patterns

**Purpose**: Define communication patterns between objects and assign responsibilities.

Examples include Observer, Strategy, Command, State, and Template Method. These patterns characterize complex control flow and communication between objects.

**In this section**: Strategy Pattern, Observer Pattern

### Structural Patterns

**Purpose**: Compose classes and objects to form larger structures.

Examples include Adapter, Bridge, Composite, Decorator, Facade, and Proxy. These patterns ease the design by identifying simple ways to realize relationships between entities.

**In this section**: Decorator Pattern

## Strategy Pattern

> **Category**: Behavioral  
> **SOLID Connection**: Open/Closed Principle  
> **Use Case**: When you need interchangeable algorithms or behaviors

### The Problem

You have a class that needs to perform an operation, but the specific implementation of that operation varies. Hardcoding different implementations leads to brittle code full of conditional logic.

```python
# BAD: Hardcoded payment logic
class OrderProcessor:
    def process_payment(self, order, payment_type):
        if payment_type == "credit_card":
            # Credit card logic
            return self._process_credit_card(order)
        elif payment_type == "paypal":
            # PayPal logic
            return self._process_paypal(order)
        elif payment_type == "bitcoin":
            # Bitcoin logic
            return self._process_bitcoin(order)
        else:
            raise ValueError("Unknown payment type")
```

**Problems**:
- Adding new payment methods requires modifying OrderProcessor (violates OCP)
- Testing each payment type requires testing the entire class
- Can't swap payment strategies at runtime easily

### The Solution: Strategy Pattern

The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. The strategy lets the algorithm vary independently from clients that use it.

```python
# GOOD: Strategy Pattern
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def process(self, order) -> bool:
        pass

class CreditCardPayment(PaymentStrategy):
    def process(self, order) -> bool:
        # Credit card specific logic
        print(f"Processing ${order.total} via Credit Card")
        return True

class PayPalPayment(PaymentStrategy):
    def process(self, order) -> bool:
        # PayPal specific logic
        print(f"Processing ${order.total} via PayPal")
        return True

class BitcoinPayment(PaymentStrategy):
    def process(self, order) -> bool:
        # Bitcoin specific logic
        print(f"Processing ${order.total} via Bitcoin")
        return True

class OrderProcessor:
    def __init__(self, payment_strategy: PaymentStrategy):
        self.payment_strategy = payment_strategy
    
    def process_payment(self, order):
        return self.payment_strategy.process(order)
```

**Benefits**:
- ✅ **Open/Closed**: Add new payment methods without modifying existing code
- ✅ **Single Responsibility**: Each strategy handles one payment type
- ✅ **Testability**: Test each strategy in isolation
- ✅ **Runtime flexibility**: Change payment strategies dynamically

### Connection to Open/Closed Principle

The Strategy Pattern is a direct implementation of OCP. The OrderProcessor is **closed for modification** (you never change it when adding payment methods) but **open for extension** (you add new payment strategies by creating new classes).

See [Open/Closed Principle](11-application-development/11.2.1-solid-principles.md#openclosed-principle-ocp) for detailed explanation of OCP.

### When to Use Strategy

- ✅ You have multiple algorithms for a specific task
- ✅ Algorithms should be interchangeable at runtime
- ✅ You want to avoid conditional logic for algorithm selection
- ✅ Algorithms have similar interfaces but different implementations

**Real-world examples**: Sorting algorithms, compression strategies, routing algorithms, payment processing, file export formats (PDF, CSV, JSON)

### Implementation Example

See the complete Python implementation with payment processing in:
`examples/ch11/classical-patterns/strategy/`

## Factory Pattern

> **Category**: Creational  
> **SOLID Connection**: Dependency Inversion Principle  
> **Use Case**: When you need to abstract object creation

### The Problem

Creating objects directly with constructors couples your code to specific classes. This makes it difficult to test and hard to change implementations.

```go
// BAD: Direct instantiation couples code to MySQL
type UserService struct {
    db *MySQLDatabase
}

func NewUserService() *UserService {
    return &UserService{
        db: &MySQLDatabase{
            host: "localhost",
            port: 3306,
        },
    }
}
```

**Problems**:
- UserService is tightly coupled to MySQL (can't test with different database)
- Switching databases requires changing UserService code
- Can't configure which database to use at runtime

### The Solution: Factory Pattern

The Factory Pattern defines an interface for creating objects but lets subclasses or implementations decide which concrete class to instantiate.

```go
// GOOD: Factory Pattern
type Database interface {
    Connect() error
    Query(sql string) ([]Row, error)
    Close() error
}

type DatabaseFactory interface {
    CreateDatabase(config Config) Database
}

// Concrete factories
type MySQLFactory struct{}

func (f *MySQLFactory) CreateDatabase(config Config) Database {
    return &MySQLDatabase{
        host: config.Host,
        port: config.Port,
    }
}

type PostgreSQLFactory struct{}

func (f *PostgreSQLFactory) CreateDatabase(config Config) Database {
    return &PostgreSQLDatabase{
        host: config.Host,
        port: config.Port,
    }
}

// Client code depends on abstractions
type UserService struct {
    db Database
}

func NewUserService(factory DatabaseFactory, config Config) *UserService {
    return &UserService{
        db: factory.CreateDatabase(config),
    }
}
```

**Benefits**:
- ✅ **Dependency Inversion**: UserService depends on Database interface, not concrete classes
- ✅ **Testability**: Inject mock database for testing
- ✅ **Flexibility**: Switch database implementations via configuration
- ✅ **Encapsulation**: Creation logic is centralized and hidden

### Connection to Dependency Inversion Principle

The Factory Pattern embodies DIP by ensuring that high-level modules (UserService) depend on abstractions (Database interface) rather than concrete implementations (MySQLDatabase). The factory provides the concrete instance, but the client only knows about the interface.

See [Dependency Inversion Principle](11-application-development/11.2.1-solid-principles.md#dependency-inversion-principle-dip) for detailed explanation of DIP.

### When to Use Factory

- ✅ Object creation is complex or requires configuration
- ✅ You want to decouple object creation from usage
- ✅ You need to create different types of objects based on conditions
- ✅ You want to centralize creation logic

**Real-world examples**: Database connections, logger creation, document parsers (JSON, XML, YAML), HTTP clients, cloud service clients (AWS, GCP, Azure)

### Implementation Example

See the complete Go implementation with database factory in:
`examples/ch11/classical-patterns/factory/`

## Observer Pattern

> **Category**: Behavioral  
> **SOLID Connection**: Dependency Inversion Principle, Interface Segregation  
> **Use Case**: When you need one-to-many dependencies between objects

### The Problem

When one object's state changes, multiple other objects need to be notified and updated. Hardcoding these dependencies creates tight coupling.

```typescript
// BAD: Tightly coupled notifications
class StockPrice {
  private price: number = 0;
  private chart: ChartDisplay;
  private table: TableDisplay;
  private alertSystem: AlertSystem;

  setPrice(newPrice: number) {
    this.price = newPrice;
    
    // Tightly coupled to specific display types
    this.chart.update(newPrice);
    this.table.update(newPrice);
    if (newPrice > 100) {
      this.alertSystem.sendAlert(newPrice);
    }
  }
}
```

**Problems**:
- StockPrice is tightly coupled to specific display implementations
- Adding new displays requires modifying StockPrice
- Can't add/remove displays at runtime
- Hard to test in isolation

### The Solution: Observer Pattern

The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

```typescript
// GOOD: Observer Pattern
interface Observer {
  update(price: number): void;
}

class StockPrice {
  private price: number = 0;
  private observers: Observer[] = [];

  attach(observer: Observer): void {
    this.observers.push(observer);
  }

  detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  setPrice(newPrice: number): void {
    this.price = newPrice;
    this.notify();
  }

  private notify(): void {
    for (const observer of this.observers) {
      observer.update(this.price);
    }
  }
}

// Concrete observers
class ChartDisplay implements Observer {
  update(price: number): void {
    console.log(`Chart updated with price: $${price}`);
  }
}

class TableDisplay implements Observer {
  update(price: number): void {
    console.log(`Table updated with price: $${price}`);
  }
}

class AlertSystem implements Observer {
  update(price: number): void {
    if (price > 100) {
      console.log(`ALERT: Price exceeded $100! Current: $${price}`);
    }
  }
}
```

**Benefits**:
- ✅ **Loose coupling**: Subject doesn't know concrete observer types
- ✅ **Open/Closed**: Add new observers without modifying subject
- ✅ **Dynamic relationships**: Attach/detach observers at runtime
- ✅ **Broadcast communication**: One change notifies multiple observers

### Connection to SOLID Principles

Observer Pattern demonstrates multiple SOLID principles:

- **Dependency Inversion**: Subject depends on Observer interface, not concrete implementations
- **Interface Segregation**: Observer interface is small and focused (just `update()`)
- **Open/Closed**: Add new observers without modifying subject

### When to Use Observer

- ✅ Multiple objects need to react to state changes
- ✅ You want loose coupling between subject and observers
- ✅ Set of observing objects can change at runtime
- ✅ Broadcasting changes to unknown number of objects

**Real-world examples**: Event systems, UI updates (React, Vue), pub/sub messaging, model-view updates (MVC), websocket notifications, monitoring systems

### Implementation Example

See the complete TypeScript implementation with stock price monitoring in:
`examples/ch11/classical-patterns/observer/`

## Decorator Pattern

> **Category**: Structural  
> **SOLID Connection**: Open/Closed Principle, Single Responsibility  
> **Use Case**: When you need to add responsibilities to objects dynamically

### The Problem

You need to add features or behaviors to objects, but inheritance creates rigid hierarchies and subclass explosion.

```python
# BAD: Inheritance explosion
class Coffee:
    def cost(self) -> float:
        return 2.0

class CoffeeWithMilk(Coffee):
    def cost(self) -> float:
        return 2.5

class CoffeeWithSugar(Coffee):
    def cost(self) -> float:
        return 2.3

class CoffeeWithMilkAndSugar(Coffee):
    def cost(self) -> float:
        return 2.8

# Need CoffeeWithMilkAndSugarAndWhippedCream?
# Need CoffeeWithMilkAndWhippedCream?
# This explodes combinatorially!
```

**Problems**:
- Need a class for every combination of features
- Can't add features dynamically at runtime
- Fragile inheritance hierarchy
- Violates Open/Closed Principle (must modify hierarchy for new features)

### The Solution: Decorator Pattern

The Decorator Pattern attaches additional responsibilities to objects dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

```python
# GOOD: Decorator Pattern
from abc import ABC, abstractmethod

class Beverage(ABC):
    @abstractmethod
    def cost(self) -> float:
        pass
    
    @abstractmethod
    def description(self) -> str:
        pass

class Coffee(Beverage):
    def cost(self) -> float:
        return 2.0
    
    def description(self) -> str:
        return "Coffee"

# Decorator base class
class BeverageDecorator(Beverage):
    def __init__(self, beverage: Beverage):
        self._beverage = beverage

# Concrete decorators
class MilkDecorator(BeverageDecorator):
    def cost(self) -> float:
        return self._beverage.cost() + 0.5
    
    def description(self) -> str:
        return self._beverage.description() + ", Milk"

class SugarDecorator(BeverageDecorator):
    def cost(self) -> float:
        return self._beverage.cost() + 0.3
    
    def description(self) -> str:
        return self._beverage.description() + ", Sugar"

class WhippedCreamDecorator(BeverageDecorator):
    def cost(self) -> float:
        return self._beverage.cost() + 0.7
    
    def description(self) -> str:
        return self._beverage.description() + ", Whipped Cream"

# Usage: Build combinations dynamically
coffee = Coffee()
coffee_with_milk = MilkDecorator(coffee)
coffee_with_milk_and_sugar = SugarDecorator(coffee_with_milk)
fancy_coffee = WhippedCreamDecorator(coffee_with_milk_and_sugar)

print(f"{fancy_coffee.description()}: ${fancy_coffee.cost()}")
# Output: Coffee, Milk, Sugar, Whipped Cream: $3.5
```

**Benefits**:
- ✅ **Open/Closed**: Add new decorators without modifying existing code
- ✅ **Single Responsibility**: Each decorator adds one feature
- ✅ **Flexibility**: Combine decorators in any order at runtime
- ✅ **Transparency**: Decorated objects look like base objects

### Connection to Open/Closed Principle

The Decorator Pattern is a textbook implementation of OCP. The base Beverage class is **closed for modification** (you never change Coffee), but **open for extension** (you add features by wrapping with decorators).

Unlike the Strategy Pattern which swaps entire algorithms, Decorator adds layers of functionality while maintaining the same interface.

See [Open/Closed Principle](11-application-development/11.2.1-solid-principles.md#openclosed-principle-ocp) for detailed explanation of OCP.

### When to Use Decorator

- ✅ Add responsibilities to objects dynamically
- ✅ Avoid subclass explosion from feature combinations
- ✅ Need to add/remove responsibilities at runtime
- ✅ Extension by subclassing is impractical

**Real-world examples**: I/O streams (BufferedReader wrapping FileReader), middleware chains (Express, Django), UI components (borders, scrollbars), logging wrappers, caching layers

### Implementation Example

See the complete Python implementation with coffee shop in:
`examples/ch11/classical-patterns/decorator/`

## Pattern Recognition in Production Code

Identifying design patterns in existing codebases is a crucial skill. Here's how to recognize the four patterns we've covered:

### Strategy Pattern Recognition

**Look for**:
- Interface or abstract class defining an algorithm
- Multiple concrete implementations of that interface
- Context class that uses the strategy via dependency injection
- No conditional logic (if/elif/switch) for algorithm selection

**Code signatures**:
```python
class SomeContext:
    def __init__(self, strategy: StrategyInterface):
        self.strategy = strategy
```

**Common naming**: `*Strategy`, `*Algorithm`, `*Handler`, `*Policy`

### Factory Pattern Recognition

**Look for**:
- Methods or classes with "Factory" in the name
- Methods that return interface types, not concrete classes
- Static methods like `create()`, `build()`, `newInstance()`
- Configuration-based object creation

**Code signatures**:
```go
func NewClient(config Config) ClientInterface {
    // Returns interface, not concrete type
}
```

**Common naming**: `*Factory`, `Create*`, `New*`, `Build*`, `Make*`

### Observer Pattern Recognition

**Look for**:
- Methods like `attach()`, `detach()`, `subscribe()`, `unsubscribe()`
- Methods like `notify()`, `notifyAll()`, `publish()`, `emit()`
- Listener or Observer interfaces
- Collections of observers/listeners maintained by subject

**Code signatures**:
```typescript
interface EventListener {
    onEvent(event: Event): void;
}

class EventEmitter {
    private listeners: EventListener[] = [];
    subscribe(listener: EventListener): void { /* ... */ }
}
```

**Common naming**: `*Observer`, `*Listener`, `*Subscriber`, `*Handler`, event emitters

### Decorator Pattern Recognition

**Look for**:
- Classes that wrap other classes of the same interface
- Constructor accepting an object of the interface being decorated
- Methods that call the wrapped object and add behavior
- Nested wrapping (decorator wrapping decorator)

**Code signatures**:
```python
class Decorator(BaseInterface):
    def __init__(self, wrapped: BaseInterface):
        self._wrapped = wrapped
    
    def operation(self):
        # Add behavior before/after
        return self._wrapped.operation()
```

**Common naming**: `*Decorator`, `*Wrapper`, stream classes (BufferedReader), middleware

## Pattern Recognition Exercise

### Self-Directed Learning

Choose a production codebase you have access to (could be open-source or from work/internship) and complete the following:

1. **Search for Strategy Pattern**:
   - Find at least one example where multiple algorithms are swapped
   - Document: What interface defines the strategy? What are the concrete implementations?
   - Analyze: Could this be improved? Is it following OCP?

2. **Search for Factory Pattern**:
   - Find at least one example of object creation abstraction
   - Document: What objects are being created? How does it support DIP?
   - Analyze: Is the factory tested independently?

3. **Search for Observer Pattern**:
   - Find at least one event system or notification mechanism
   - Document: What is the subject? What are the observers?
   - Analyze: Can observers be added/removed dynamically?

4. **Search for Decorator Pattern**:
   - Find at least one example of behavior wrapping
   - Document: What is being decorated? What behaviors are added?
   - Analyze: Could you add more decorators without modifying existing code?

### Reflection Questions

After your exploration, consider:

- Which pattern was easiest to find? Why?
- Which pattern was hardest to recognize? Why?
- Did you find any anti-patterns (patterns used incorrectly)?
- How do these patterns contribute to the codebase's maintainability?
- Which SOLID principles are most evident in the patterns you found?

### Recommended Codebases

If you need suggestions for codebases to explore:

- **Python**: Django (web framework), Requests (HTTP library), Flask (web framework)
- **Go**: Kubernetes (container orchestration), Docker (containerization), Terraform (IaC)
- **TypeScript**: VSCode (editor), React (UI library), NestJS (backend framework)
- **Java**: Spring Framework, JUnit (testing), Apache Commons

Look for patterns in core libraries and frameworks—they tend to be excellent examples of pattern usage.

## Quiz

```quiz
quiz: /src/quizzes/chapter-11/11.2.4/classical-patterns-quiz.js
```

## Summary

The four classical Gang of Four patterns we've covered represent essential tools for writing maintainable, extensible code:

| Pattern | Category | SOLID Connection | Use Case |
|---------|----------|------------------|----------|
| **Strategy** | Behavioral | Open/Closed | Swappable algorithms |
| **Factory** | Creational | Dependency Inversion | Object creation abstraction |
| **Observer** | Behavioral | Dependency Inversion, Interface Segregation | Event-driven updates |
| **Decorator** | Structural | Open/Closed, Single Responsibility | Dynamic behavior extension |

### Key Takeaways

1. **Patterns embody SOLID**: Each pattern is a practical application of one or more SOLID principles
2. **Patterns solve specific problems**: Don't use patterns for the sake of using patterns—use them when they solve real problems
3. **Patterns are language-agnostic**: The same pattern works in Python, Go, TypeScript, or any OO language
4. **Patterns enable communication**: Saying "use the Strategy Pattern" conveys a design idea instantly

### When NOT to Use Patterns

Remember the principle of **YAGNI** (You Aren't Gonna Need It):

- Don't use Strategy if you only have one algorithm and no plans for more
- Don't use Factory if you're only creating one type of object
- Don't use Observer if you have one subscriber that never changes
- Don't use Decorator if you're not adding multiple layers of behavior

**Premature abstraction is as bad as premature optimization**. Use patterns when you see the need, not speculatively.

### Next Steps

- Review [SOLID Principles](11-application-development/11.2.1-solid-principles.md) to deepen your understanding of the foundations
- Explore the complete code examples in `examples/ch11/classical-patterns/`
- Complete the pattern recognition exercise with a real codebase
- Study the remaining 19 GoF patterns when you need them

The Gang of Four patterns have stood the test of time because they solve real problems in maintainable ways. Understanding these four gives you a strong foundation for recognizing and applying patterns throughout your career.

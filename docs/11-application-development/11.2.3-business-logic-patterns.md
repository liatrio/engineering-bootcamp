---
docs/11-application-development/11.2.3-business-logic-patterns.md:
  category: Software Development
  estReadingMinutes: 30
  exercises:
    -
      name: Implement Business Logic Patterns
      description: Choose and implement the appropriate business logic pattern (Transaction Script, Domain Model, or Service Layer) for a given business problem based on complexity.
      estMinutes: 90
      technologies:
      - TypeScript
      - Design Patterns
---

# Business Logic Patterns

Business logic is the heart of your application—the code that implements the rules, workflows, and constraints of your business domain. How you organize this logic has a profound impact on maintainability, testability, and the ability to evolve your application over time.

This section explores three fundamental patterns for organizing business logic:

- **Transaction Script** - Procedural organization for simple domains
- **Domain Model** - Object-oriented encapsulation for complex domains
- **Service Layer** - Orchestration and transaction boundaries

## Overview

The choice of business logic pattern depends on the complexity of your domain, team experience, and maintainability requirements:

| Pattern | Best For | Complexity | Team Experience | Example Use Case |
| ------- | -------- | ---------- | --------------- | ---------------- |
| **Transaction Script** | Simple CRUD operations | Low | Junior-friendly | Basic order processing |
| **Domain Model** | Rich business rules | High | OOP experience needed | Complex pricing rules |
| **Service Layer** | Application orchestration | Medium-High | Architecture understanding | API coordination |

## Transaction Script Pattern

### What is Transaction Script?

Transaction Script organizes business logic as a set of procedures (functions or methods) where each procedure handles a single request from the presentation layer. Think of it as a straightforward, procedural approach where each transaction has its own script.

**Key Characteristics:**
- Business logic organized as procedural functions
- Each function represents one transaction/use case
- Direct and easy to understand
- Minimal abstraction overhead

### When to Use Transaction Script

✅ **Good fit when:**
- Domain logic is simple and straightforward
- Operations are mostly CRUD (Create, Read, Update, Delete)
- Team is small or has limited OOP experience
- Time to market is critical
- You're building MVPs or prototypes

❌ **Poor fit when:**
- Business rules are complex and interconnected
- You need rich domain behavior
- Code reuse becomes challenging
- Duplication starts appearing across scripts

### Example: Order Processing

```typescript
// Transaction Script approach - procedural functions
interface OrderData {
  customerId: number;
  items: Array<{ productId: number; quantity: number; price: number }>;
  couponCode?: string;
}

function calculateOrderTotal(orderData: OrderData): number {
  let total = 0;
  for (const item of orderData.items) {
    total += item.price * item.quantity;
  }
  return total;
}

function applyDiscount(total: number, couponCode?: string): number {
  if (!couponCode) return total;
  
  // Simple discount logic
  if (couponCode === 'SAVE10') {
    return total * 0.9;
  } else if (couponCode === 'SAVE20') {
    return total * 0.8;
  }
  return total;
}

function processOrder(orderData: OrderData): void {
  // Validation
  if (!orderData.items || orderData.items.length === 0) {
    throw new Error('Order must have at least one item');
  }
  
  // Calculate totals
  const subtotal = calculateOrderTotal(orderData);
  const total = applyDiscount(subtotal, orderData.couponCode);
  
  // Save to database (simplified)
  console.log(`Processing order for customer ${orderData.customerId}`);
  console.log(`Total: $${total.toFixed(2)}`);
  
  // Send confirmation (simplified)
  console.log('Order confirmation sent');
}
```

**Benefits:**
- **Simplicity**: Easy to understand and implement
- **Directness**: Clear path from request to response
- **Fast development**: Quick to build simple features

**Trade-offs:**
- **Duplication**: Common logic may be repeated across scripts
- **Limited reuse**: Hard to share behavior between transactions
- **Scalability issues**: Becomes unwieldy as complexity grows

See the [Transaction Script example](/examples/ch11/business-patterns/transaction-script/) for a complete working implementation.

## Domain Model Pattern

### What is Domain Model?

Domain Model organizes business logic as a network of interconnected objects, where each object represents a concept from your business domain. Objects encapsulate both data and behavior, following object-oriented principles.

**Key Characteristics:**
- Business logic encapsulated in domain objects
- Rich behavior on objects (not just data holders)
- Objects collaborate to fulfill business rules
- Follows object-oriented design principles

### When to Use Domain Model

✅ **Good fit when:**
- Complex business rules and workflows
- Rich domain behavior needed
- Code reuse and maintainability are priorities
- Team has strong OOP experience
- Long-term evolution expected

❌ **Poor fit when:**
- Domain is simple with minimal rules
- Team lacks OOP experience
- Rapid prototyping is the priority
- Overhead of OOP is not justified

### Example: Order Processing

```typescript
// Domain Model approach - rich objects with behavior
class Order {
  private items: OrderItem[] = [];
  private coupon?: Coupon;
  
  constructor(
    private customerId: number,
    private customer: Customer
  ) {}
  
  addItem(product: Product, quantity: number): void {
    const item = new OrderItem(product, quantity);
    this.items.push(item);
  }
  
  applyCoupon(coupon: Coupon): void {
    if (!coupon.isValid()) {
      throw new Error('Coupon is not valid');
    }
    this.coupon = coupon;
  }
  
  calculateTotal(): number {
    const subtotal = this.calculateSubtotal();
    const discount = this.calculateDiscount(subtotal);
    return subtotal - discount;
  }
  
  private calculateSubtotal(): number {
    return this.items.reduce((sum, item) => sum + item.getTotal(), 0);
  }
  
  private calculateDiscount(subtotal: number): number {
    if (!this.coupon) return 0;
    
    let discount = this.coupon.calculateDiscount(subtotal);
    
    // Customer-specific discounts
    if (this.customer.isVIP()) {
      discount += subtotal * 0.05; // Additional 5% for VIP
    }
    
    return discount;
  }
  
  process(): void {
    if (this.items.length === 0) {
      throw new Error('Order must have at least one item');
    }
    
    const total = this.calculateTotal();
    console.log(`Processing order for customer ${this.customerId}`);
    console.log(`Total: $${total.toFixed(2)}`);
  }
}

class OrderItem {
  constructor(
    private product: Product,
    private quantity: number
  ) {}
  
  getTotal(): number {
    return this.product.getPrice() * this.quantity;
  }
}

class Product {
  constructor(
    private id: number,
    private name: string,
    private price: number
  ) {}
  
  getPrice(): number {
    return this.price;
  }
}

class Customer {
  constructor(
    private id: number,
    private name: string,
    private vipStatus: boolean = false
  ) {}
  
  isVIP(): boolean {
    return this.vipStatus;
  }
}

class Coupon {
  constructor(
    private code: string,
    private discountPercent: number,
    private expiryDate: Date
  ) {}
  
  isValid(): boolean {
    return new Date() <= this.expiryDate;
  }
  
  calculateDiscount(amount: number): number {
    return amount * (this.discountPercent / 100);
  }
}
```

**Benefits:**
- **Encapsulation**: Business rules live with the data they operate on
- **Reusability**: Behavior can be shared and inherited
- **Maintainability**: Changes are localized to specific objects
- **Expressiveness**: Code reads like the business domain

**Trade-offs:**
- **Complexity**: More objects and relationships to manage
- **Learning curve**: Requires OOP expertise
- **Overhead**: May be overkill for simple domains

See the [Domain Model example](/examples/ch11/business-patterns/domain-model/) for a complete working implementation.

## Service Layer Pattern

### What is Service Layer?

Service Layer defines an application's boundary with a layer of services that orchestrates domain objects and defines transaction boundaries. It's the facade that your presentation layer (API, UI) interacts with.

**Key Characteristics:**
- Encapsulates application logic (use cases)
- Defines transaction boundaries
- Coordinates domain objects
- Provides a clear API for the presentation layer

### When to Use Service Layer

✅ **Good fit when:**
- Multiple clients need the same business operations (web, mobile, API)
- Transaction boundaries need to be explicit
- You need to coordinate multiple domain objects
- Application logic is separate from domain logic

❌ **Poor fit when:**
- Application is extremely simple (single page CRUD)
- Direct presentation-to-domain coupling is acceptable
- Overhead of additional layer isn't justified

### Example: Order Service

```typescript
// Service Layer - orchestrates domain objects
class OrderService {
  constructor(
    private orderRepository: OrderRepository,
    private productRepository: ProductRepository,
    private customerRepository: CustomerRepository,
    private emailService: EmailService
  ) {}
  
  async createOrder(
    customerId: number,
    items: Array<{ productId: number; quantity: number }>,
    couponCode?: string
  ): Promise<Order> {
    // Start transaction boundary
    try {
      // Fetch domain objects
      const customer = await this.customerRepository.findById(customerId);
      if (!customer) {
        throw new Error('Customer not found');
      }
      
      // Create order and add items
      const order = new Order(customerId, customer);
      
      for (const item of items) {
        const product = await this.productRepository.findById(item.productId);
        if (!product) {
          throw new Error(`Product ${item.productId} not found`);
        }
        order.addItem(product, item.quantity);
      }
      
      // Apply coupon if provided
      if (couponCode) {
        const coupon = await this.getCoupon(couponCode);
        order.applyCoupon(coupon);
      }
      
      // Process and save
      order.process();
      await this.orderRepository.save(order);
      
      // Send confirmation email
      await this.emailService.sendOrderConfirmation(customer.getEmail(), order);
      
      return order;
    } catch (error) {
      // Rollback transaction
      console.error('Failed to create order:', error);
      throw error;
    }
  }
  
  async getOrderTotal(orderId: number): Promise<number> {
    const order = await this.orderRepository.findById(orderId);
    if (!order) {
      throw new Error('Order not found');
    }
    return order.calculateTotal();
  }
  
  private async getCoupon(code: string): Promise<Coupon> {
    // Fetch coupon from repository
    // Simplified for example
    return new Coupon(code, 10, new Date('2026-12-31'));
  }
}

// Repository interfaces (dependency injection)
interface OrderRepository {
  findById(id: number): Promise<Order | null>;
  save(order: Order): Promise<void>;
}

interface ProductRepository {
  findById(id: number): Promise<Product | null>;
}

interface CustomerRepository {
  findById(id: number): Promise<Customer | null>;
}

interface EmailService {
  sendOrderConfirmation(email: string, order: Order): Promise<void>;
}
```

**Benefits:**
- **Clear boundaries**: Defines what the application can do
- **Transaction control**: Explicit transaction management
- **Coordination**: Orchestrates multiple domain objects
- **Testability**: Easy to mock dependencies

**Trade-offs:**
- **Additional layer**: More code to write and maintain
- **Indirection**: One more hop between presentation and domain
- **Can become bloated**: Risk of becoming a "god service"

See the [Service Layer example](/examples/ch11/business-patterns/service-layer/) for a complete working implementation.

## Transaction Script vs Domain Model: A Comparison

The choice between Transaction Script and Domain Model is one of the most important architectural decisions you'll make. Let's compare them side by side solving the same problem.

### The Problem: Calculate Order Discount

**Business Rules:**
- 10% discount for orders over $100
- 5% additional discount for VIP customers
- Coupon codes can provide additional percentage discounts
- Maximum total discount is 30%

### Transaction Script Solution

```typescript
function calculateOrderDiscount(
  orderTotal: number,
  isVIP: boolean,
  couponCode?: string
): number {
  let discount = 0;
  
  // Volume discount
  if (orderTotal > 100) {
    discount += orderTotal * 0.10;
  }
  
  // VIP discount
  if (isVIP) {
    discount += orderTotal * 0.05;
  }
  
  // Coupon discount
  if (couponCode === 'SAVE10') {
    discount += orderTotal * 0.10;
  } else if (couponCode === 'SAVE20') {
    discount += orderTotal * 0.20;
  }
  
  // Cap at 30%
  const maxDiscount = orderTotal * 0.30;
  return Math.min(discount, maxDiscount);
}
```

**Pros:**
- Simple and direct
- Easy to understand
- Fast to implement

**Cons:**
- Business rules scattered in procedural code
- Hard to test individual discount types
- Difficult to add new discount types
- Coupon logic hardcoded

### Domain Model Solution

```typescript
class Order {
  private discountCalculator: DiscountCalculator;
  
  calculateDiscount(): number {
    return this.discountCalculator.calculate(this);
  }
}

class DiscountCalculator {
  private strategies: DiscountStrategy[] = [];
  
  addStrategy(strategy: DiscountStrategy): void {
    this.strategies.push(strategy);
  }
  
  calculate(order: Order): number {
    const total = order.getTotal();
    let discount = 0;
    
    for (const strategy of this.strategies) {
      discount += strategy.calculate(order);
    }
    
    // Cap at 30%
    const maxDiscount = total * 0.30;
    return Math.min(discount, maxDiscount);
  }
}

interface DiscountStrategy {
  calculate(order: Order): number;
}

class VolumeDiscount implements DiscountStrategy {
  calculate(order: Order): number {
    const total = order.getTotal();
    return total > 100 ? total * 0.10 : 0;
  }
}

class VIPDiscount implements DiscountStrategy {
  calculate(order: Order): number {
    if (order.getCustomer().isVIP()) {
      return order.getTotal() * 0.05;
    }
    return 0;
  }
}

class CouponDiscount implements DiscountStrategy {
  constructor(private coupon: Coupon) {}
  
  calculate(order: Order): number {
    if (this.coupon.isValid()) {
      return order.getTotal() * (this.coupon.getDiscountPercent() / 100);
    }
    return 0;
  }
}
```

**Pros:**
- Each discount type is isolated and testable
- Easy to add new discount types (Open/Closed Principle)
- Business rules are explicit and named
- Highly maintainable

**Cons:**
- More classes and code
- Requires OOP understanding
- May be overkill for simple cases

### Decision Criteria

| Criterion | Choose Transaction Script | Choose Domain Model |
| --------- | ------------------------- | ------------------- |
| **Domain Complexity** | Simple, straightforward rules | Complex, interconnected rules |
| **Number of Rules** | < 10 business rules | 10+ business rules |
| **Change Frequency** | Stable requirements | Frequently changing |
| **Team Experience** | Junior developers | OOP-experienced team |
| **Code Reuse Needs** | Minimal | Extensive |
| **Testability** | Simple integration tests | Granular unit tests needed |
| **Project Lifespan** | Short-term/prototype | Long-term/production |

See the [Comparison example](/examples/ch11/business-patterns/comparison/) for working implementations of both approaches.

## Anti-Patterns: Where NOT to Put Business Logic

### ❌ Business Logic in Controllers

```typescript
// BAD: Business logic in the controller
app.post('/orders', async (req, res) => {
  const { customerId, items, couponCode } = req.body;
  
  // Validation in controller
  if (!items || items.length === 0) {
    return res.status(400).json({ error: 'No items' });
  }
  
  // Calculation in controller
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  
  // Discount logic in controller
  if (couponCode === 'SAVE10') {
    total *= 0.9;
  }
  
  // Database access in controller
  await db.execute('INSERT INTO orders ...');
  
  res.json({ orderId: 123, total });
});
```

**Problems:**
- Cannot reuse logic for mobile app, CLI, or other interfaces
- Cannot test business logic without HTTP layer
- Violates Single Responsibility Principle
- Difficult to maintain as logic grows

**Fix:** Move to Transaction Script, Domain Model, or Service Layer

### ❌ Business Logic in Views/Templates

```html
<!-- BAD: Business logic in template -->
<div class="order-total">
  {% if order.total > 100 %}
    {% set discount = order.total * 0.1 %}
  {% else %}
    {% set discount = 0 %}
  {% endif %}
  
  {% if customer.is_vip %}
    {% set discount = discount + order.total * 0.05 %}
  {% endif %}
  
  Total: ${{ order.total - discount }}
</div>
```

**Problems:**
- Business rules duplicated if used in API or other views
- Impossible to unit test
- Hard to find and update logic
- Violates separation of concerns

**Fix:** Calculate in business layer, pass results to view

### ❌ Business Logic in Data Access Layer

```typescript
// BAD: Business logic in repository
class OrderRepository {
  async save(order: OrderData): Promise<void> {
    // Validation in repository
    if (order.total > 10000) {
      throw new Error('Orders over $10,000 require approval');
    }
    
    // Business rule in repository
    if (order.customer.isVIP) {
      order.discount = order.total * 0.05;
    }
    
    await this.db.insert('orders', order);
  }
}
```

**Problems:**
- Repositories should only handle data persistence
- Business rules hidden in data layer
- Cannot reuse logic with different data sources
- Violates separation of concerns

**Fix:** Move to business logic layer, repository only persists

## Exercises

### Exercise 1: Identify the Pattern

For each code snippet, identify whether it uses Transaction Script, Domain Model, or contains anti-patterns:

1. A function `processPayment(amount, cardNumber, cvv)` that validates input, charges the card, and sends a receipt
2. A `ShoppingCart` class with methods `addItem()`, `removeItem()`, `calculateTotal()`, and `applyPromotion()`
3. An Express route handler that fetches data, applies business rules, and returns JSON
4. A `PaymentService` class that coordinates `PaymentGateway`, `Transaction`, and `Receipt` objects

### Exercise 2: Refactor Transaction Script to Domain Model

Given a transaction script for invoice processing:

```typescript
function processInvoice(invoiceData: InvoiceData): void {
  // Calculate totals
  let subtotal = 0;
  for (const item of invoiceData.items) {
    subtotal += item.price * item.quantity;
  }
  
  // Apply tax
  const tax = subtotal * 0.08;
  
  // Apply payment terms discount
  let discount = 0;
  if (invoiceData.paymentTerms === 'NET15') {
    discount = subtotal * 0.02;
  } else if (invoiceData.paymentTerms === 'NET30') {
    discount = subtotal * 0.01;
  }
  
  const total = subtotal + tax - discount;
  
  // Save and send
  saveInvoice({ ...invoiceData, total });
  sendInvoiceEmail(invoiceData.customerEmail, total);
}
```

**Your task:** Refactor this into a Domain Model with:
- `Invoice` class with items and payment terms
- `InvoiceItem` class
- `PaymentTerms` class or enum
- Appropriate methods encapsulating business logic

### Exercise 3: Build a Service Layer

Create a `ProductCatalogService` that:
- Fetches products from a repository
- Applies category-based discounts
- Filters products by availability
- Returns formatted product listings

Define clear transaction boundaries and dependencies.

## Self-Directed Exercise: E-commerce Order System

**Objective:** Implement an order processing system using the pattern appropriate for the given complexity level.

**Scenario:** You're building an e-commerce order system with the following requirements:

**Level 1 (Simple) - Use Transaction Script:**
- Create orders with items
- Calculate subtotal (sum of item prices)
- Apply a single flat discount if order > $50
- Save to database

**Level 2 (Moderate) - Use Domain Model:**
- All Level 1 requirements, plus:
- VIP customers get 10% discount
- Promotional codes provide variable discounts
- Maximum discount cap of 30%
- Items can be in different categories with category-specific rules

**Level 3 (Complex) - Use Service Layer + Domain Model:**
- All Level 2 requirements, plus:
- Coordinate with inventory service to check stock
- Coordinate with payment service to process payment
- Send order confirmation email
- Handle transaction rollback on failure
- Support multiple concurrent order requests

**Success Criteria:**
- Code runs and passes tests
- Pattern choice matches complexity level
- Business logic is clearly separated from infrastructure
- Code is testable and maintainable

## Interactive Quiz

<div id="quiz-11-2-3"></div>
<script src="/src/quizzes/chapter-11/11.2.3/business-logic-patterns-quiz.js"></script>

## Summary

Choosing the right pattern for organizing business logic is crucial for long-term maintainability:

- **Transaction Script** is perfect for simple domains where directness and speed trump complexity
- **Domain Model** shines when business rules are complex and require rich object behavior
- **Service Layer** provides clear application boundaries and transaction management
- **Anti-patterns** to avoid: business logic in controllers, views, or data access layers

The key is to **start simple and evolve** as complexity demands. Don't over-engineer with Domain Model when Transaction Script suffices, but recognize when procedural code becomes unwieldy and refactor toward richer models.

## Further Reading

- [Patterns of Enterprise Application Architecture](https://martinfowler.com/books/eaa.html) by Martin Fowler - The definitive guide to these patterns
- [Domain-Driven Design](https://www.domainlanguage.com/ddd/) by Eric Evans - Deep dive into Domain Model
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) by Robert C. Martin - Architectural boundaries and dependencies

---
docs/11-application-development/11.2.2-data-layer-patterns.md:
  category: Software Development
  estReadingMinutes: 45
  exercises:
    -
      name: Refactor Direct Data Access to Repository Pattern
      description: Convert a tightly coupled application with direct database access scattered throughout the codebase to use the Repository Pattern with proper abstraction.
      estMinutes: 90
      technologies:
      - Go
      - SQLite
      - Design Patterns
---
# Data Layer Patterns

Data layer patterns provide proven approaches for organizing how your application accesses and manages data. These patterns build on the [Layered Architecture](11-application-development/11.1-layers.md) foundation and apply [SOLID Principles](11-application-development/11.2.1-solid-principles.md) to data access concerns.

This section covers two fundamental data access patterns (Repository and Active Record) and two critical concurrency patterns (Optimistic and Pessimistic Locking) that you'll encounter in production applications.

## Why Data Layer Patterns Matter

Consider a typical web application: users create accounts, update profiles, place orders, and manage inventory. Without proper patterns, data access code becomes:

- **Scattered**: SQL queries spread throughout controllers, services, and business logic
- **Duplicated**: The same query written multiple times in different places
- **Fragile**: Changing the database schema requires hunting through the entire codebase
- **Untestable**: Business logic tightly coupled to database implementation
- **Unsafe**: Concurrent updates causing data corruption

Data layer patterns solve these problems by providing structure for data access operations.

## The Anti-Pattern: Direct Data Access Everywhere

Let's see what happens when data access logic is mixed with business logic:

\`\`\`go
// BAD: Data access mixed with business logic
func CreateOrder(w http.ResponseWriter, r *http.Request) {
    var order Order
    json.NewDecoder(r.Body).Decode(&order)

    // SQL query directly in HTTP handler!
    db.Exec("INSERT INTO orders (user_id, total) VALUES (?, ?)",
            order.UserID, order.Total)

    // More SQL in the handler
    var user User
    db.QueryRow("SELECT * FROM users WHERE id = ?", order.UserID).Scan(&user)

    // Business logic mixed in
    if user.AccountType == "premium" {
        order.Total = order.Total * 0.9  // 10% discount
    }

    // Another query
    db.Exec("UPDATE orders SET total = ? WHERE id = ?", order.Total, order.ID)

    json.NewEncoder(w).Encode(order)
}
\`\`\`

**Problems with this approach:**

1. **Can't test business logic** without a database
2. **Can't switch databases** (SQL queries hardcoded everywhere)
3. **Can't reuse logic** (order creation tied to HTTP handler)
4. **Hard to understand** (what's business logic vs data access?)
5. **No transaction safety** (what if the update fails?)

## Repository Pattern

The Repository Pattern creates an abstraction layer between business logic and data access. It provides a collection-like interface for accessing domain objects.

### Core Concept

Think of a repository as a "smart collection in memory" that happens to be backed by a database:

\`\`\`go
// Define what operations are available, not how they work
type UserRepository interface {
    Create(user *User) error
    FindByID(id int) (\*User, error)
    FindAll() ([]\ *User, error)
    Update(user \*User) error
    Delete(id int) error
}
\`\`\`

The interface defines **what** operations are available without specifying **how** they're implemented.

### Benefits

**1. Abstraction**: Business logic doesn't know or care where data comes from

\`\`\`go
// Business logic depends on interface, not implementation
type UserService struct {
    repo UserRepository  // Could be SQL, NoSQL, in-memory, API...
}

func (s *UserService) RegisterUser(name, email string) (*User, error) {
    user := &User{Name: name, Email: email}
    return user, s.repo.Create(user)  // Don't care how it's stored
}
\`\`\`

**2. Testability**: Easy to create mock repositories for testing

\`\`\`go
// Test with in-memory implementation
func TestUserService(t *testing.T) {
    repo := NewInMemoryUserRepository()  // No database needed!
    service := NewUserService(repo)

    user, err := service.RegisterUser("Alice", "alice@example.com")
    // Test business logic without database
}
\`\`\`

**3. Flexibility**: Switch storage implementations without touching business logic

\`\`\`go
// Production: Use SQL
sqlRepo := NewSQLiteUserRepository(db)
service := NewUserService(sqlRepo)

// Testing: Use in-memory
memRepo := NewInMemoryUserRepository()
service := NewUserService(memRepo)

// Future: Switch to MongoDB without changing UserService!
mongoRepo := NewMongoUserRepository(client)
service := NewUserService(mongoRepo)
\`\`\`

### Example Implementation

See the complete working example in [\`examples/ch11/data-patterns/repository/\`](/examples/ch11/data-patterns/repository/) which demonstrates:

- Interface definition for \`UserRepository\`
- SQLite implementation with SQL queries
- In-memory implementation for testing
- Service layer using the repository
- Unit tests for both implementations

Run the example:

\`\`\`bash
cd examples/ch11/data-patterns/repository
go run .
\`\`\`

### When to Use Repository Pattern

**Use Repository when:**
- You need to support multiple data sources (SQL, NoSQL, APIs)
- Testability is important (mocking data access for unit tests)
- You have complex query logic that should be centralized
- Your domain model is distinct from your data model
- You follow Domain-Driven Design principles

**Consider alternatives when:**
- Your application is simple CRUD with no complex business logic
- You're using an ORM that already provides repository-like features
- The abstraction overhead isn't justified by your use case

## Active Record Pattern

The Active Record Pattern takes a different approach: domain objects contain both data and the methods to persist themselves.

### Core Concept

With Active Record, objects know how to save, update, and delete themselves:

\`\`\`go
user := &User{Name: "Alice", Email: "alice@example.com"}
user.Save()      // Object saves itself to the database
user.Name = "Alice Smith"
user.Save()      // Object updates itself
user.Delete()    // Object deletes itself
\`\`\`

### Benefits

**1. Simplicity**: Straightforward, intuitive API

\`\`\`go
// Creating and saving is simple
user := &User{Name: "Bob", Email: "bob@example.com"}
user.Save()

// Finding is simple (class methods)
found, err := FindUserByID(1)

// Updating is simple
found.Name = "Robert"
found.Save()
\`\`\`

**2. Less Boilerplate**: No need for separate repository classes

\`\`\`go
// Active Record: Persistence is built-in
type User struct {
    ID    int
    Name  string
    Email string
}

func (u *User) Save() error {
    // Persistence logic here
}

// Repository: Requires separate class
type User struct {
    ID    int
    Name  string
    Email string
}

type UserRepository interface {
    Save(user *User) error
}
\`\`\`

**3. Convention over Configuration**: Works well with frameworks that support it (Rails, Laravel, Django)

### Example Implementation

See the complete working example in [\`examples/ch11/data-patterns/active-record/\`](/examples/ch11/data-patterns/active-record/) which demonstrates:

- \`User\` struct with \`Save()\`, \`Delete()\`, \`Reload()\` methods
- Class methods for finding: \`FindUserByID()\`, \`FindUserByEmail()\`, \`AllUsers()\`
- Built-in validation with \`Validate()\`
- Unit tests for all operations

Run the example:

\`\`\`bash
cd examples/ch11/data-patterns/active-record
go run .
\`\`\`

### When to Use Active Record Pattern

**Use Active Record when:**
- Your domain model maps closely to database tables (1:1 relationship)
- You need rapid development with minimal boilerplate
- You're using a framework that supports Active Record (Rails, Laravel)
- Your application is primarily CRUD operations
- Simplicity and convention are priorities

**Consider Repository Pattern instead when:**
- You need to support multiple data sources
- Testability with mocks is critical
- You want complete separation between domain and persistence
- Your domain model is complex and doesn't map 1:1 to tables

## Repository vs Active Record: Decision Guide

| Aspect | Repository | Active Record |
|--------|------------|---------------|
| **Abstraction** | High - separate repository classes | Low - persistence in domain objects |
| **Testability** | Excellent - easy to mock interface | Harder - domain objects coupled to DB |
| **Complexity** | More complex - additional classes needed | Simpler - fewer classes |
| **Flexibility** | High - easy to swap implementations | Lower - tied to database structure |
| **Domain Model** | Persistence-ignorant (clean) | Persistence-aware (practical) |
| **Learning Curve** | Steeper - more concepts | Gentler - intuitive API |
| **Best For** | Complex domains, multiple data sources | Simple CRUD, rapid development |
| **Framework Support** | Manual implementation needed | Built-in to Rails, Laravel, Django |

**Rule of Thumb**: Start with Active Record for simplicity. If you need to support multiple data sources or struggle with testing, refactor to Repository Pattern.

## Concurrency Patterns

When multiple users access the same data simultaneously, you need concurrency control to prevent data corruption. There are two main approaches:

### Optimistic Locking

**Philosophy**: Conflicts are rare, so don't lock upfront. Detect conflicts when they happen.

**How it works:**

1. Add a \`version\` field to each record
2. Read data without locks (include version)
3. When updating, check if version changed
4. If version matches → update and increment version
5. If version changed → conflict detected, retry

\`\`\`go
// Optimistic Locking with version field
type Product struct {
    ID       int
    Name     string
    Quantity int
    Version  int  // Increments on each update
}

// Update only succeeds if version matches
UPDATE products
SET quantity = ?, version = version + 1
WHERE id = ? AND version = ?  // Conditional on version
\`\`\`

**Multi-User Scenario:**

| Time | User A | User B |
|------|--------|--------|
| T1 | Read: qty=10, version=1 | |
| T2 | | Read: qty=10, version=1 |
| T3 | Update: qty=5, version=2 ✓ | |
| T4 | | Update fails: version mismatch ✗ |
| T5 | | Retry: Read qty=5, version=2 |
| T6 | | Update: qty=2, version=3 ✓ |

User B's first update fails because the version changed (User A updated it). User B retries with fresh data.

### Example Implementation

See the complete working example in [\`examples/ch11/data-patterns/concurrency/optimistic/\`](/examples/ch11/data-patterns/concurrency/optimistic/) which demonstrates:

- Version-based conflict detection
- Automatic retry logic with \`SafeUpdate()\`
- Multi-user concurrent access simulation
- Comprehensive tests for conflict scenarios

Run the example:

\`\`\`bash
cd examples/ch11/data-patterns/concurrency/optimistic
go run .
\`\`\`

### When to Use Optimistic Locking

**Use Optimistic Locking when:**
- Conflicts are rare (high read-to-write ratio)
- Users can retry failed operations easily
- Performance is critical (no blocking)
- You have many concurrent readers

**Example Use Cases:**
- E-commerce inventory (occasional purchases)
- Document editing with conflict detection
- Profile updates (users edit their own data)
- Configuration management

### Pessimistic Locking

**Philosophy**: Conflicts are likely, so lock resources upfront to guarantee exclusive access.

**How it works:**

1. Start a database transaction
2. Acquire exclusive lock when reading (\`SELECT FOR UPDATE\`)
3. Perform all operations while holding the lock
4. Commit (releases lock) or rollback (releases lock)

\`\`\`go
// Pessimistic Locking with transaction
tx, _ := db.Begin()

// Lock acquired here - others must wait
account := FindByIDForUpdate(tx, accountID)

// Perform operations (still locked)
account.Balance -= 100
Update(tx, account)

// Lock released here
tx.Commit()
\`\`\`

**Multi-User Scenario:**

| Time | User A (Transfer $300) | User B (Transfer $200) |
|------|------------------------|------------------------|
| T1 | Begin transaction | |
| T2 | Lock account, read: $1000 | |
| T3 | | Begin transaction |
| T4 | | Try to lock account... WAITS |
| T5 | Deduct $300 → $700 | |
| T6 | Commit (releases lock) | |
| T7 | | Lock acquired, read: $700 |
| T8 | | Deduct $200 → $500 |
| T9 | | Commit |

User B waits at T4 until User A commits at T6. This guarantees consistency but reduces concurrency.

### Example Implementation

See the complete working example in [\`examples/ch11/data-patterns/concurrency/pessimistic/\`](/examples/ch11/data-patterns/concurrency/pessimistic/) which demonstrates:

- Transaction-based exclusive locking
- Safe money transfers between accounts
- Deadlock prevention through consistent lock ordering
- \`WithLock()\` helper for locked operations
- Comprehensive tests including rollback scenarios

Run the example:

\`\`\`bash
cd examples/ch11/data-patterns/concurrency/pessimistic
go run .
\`\`\`

### When to Use Pessimistic Locking

**Use Pessimistic Locking when:**
- Conflicts are common (many concurrent updates)
- The cost of conflicts is high (financial transactions)
- Retries are expensive or not user-friendly
- Immediate consistency is critical

**Example Use Cases:**
- Banking transactions (money transfers, withdrawals)
- Seat reservations (planes, theaters, events)
- Inventory allocation (e-commerce order processing)
- Critical system configuration updates

## Optimistic vs Pessimistic Locking

| Aspect | Optimistic | Pessimistic |
|--------|------------|-------------|
| **Assumption** | Conflicts are rare | Conflicts are common |
| **Locking** | No locks during read | Locks acquired on read |
| **Conflict Handling** | Detect and retry | Prevent with locks |
| **Concurrency** | High (no blocking) | Lower (blocking waits) |
| **Performance** | Better with few conflicts | Better with many conflicts |
| **Complexity** | Requires retry logic | Simpler - guaranteed exclusive access |
| **Best For** | Read-heavy workloads | Write-heavy workloads |
| **Example** | Product inventory viewing | Bank account transfers |

**Hybrid Approach**: You can use both! Optimistic for reads, Pessimistic for critical writes:

\`\`\`go
// Optimistic: Quick profile updates (rare conflicts)
user.Version = currentVersion
user.Name = newName
repo.Update(user)  // Fails if version changed

// Pessimistic: Critical money transfer (must succeed)
tx.Begin()
fromAccount := FindByIDForUpdate(tx, fromID)  // Lock
toAccount := FindByIDForUpdate(tx, toID)      // Lock
Transfer(fromAccount, toAccount, amount)
tx.Commit()  // Releases locks
\`\`\`

## Exercises

### Exercise 1: Refactor Direct Data Access to Repository Pattern

**Scenario**: You've inherited a codebase where SQL queries are scattered throughout HTTP handlers, making it impossible to test business logic.

**Task**: Refactor the application to use the Repository Pattern.

**Steps**:

1. Identify all direct database access in the codebase
2. Define a repository interface for each entity (\`UserRepository\`, \`OrderRepository\`, etc.)
3. Create implementations for each interface (start with existing SQL)
4. Update business logic to use repositories instead of direct database access
5. Create in-memory implementations for testing
6. Write unit tests for business logic using mock repositories

**Learning Goals**:
- Understand how to extract data access logic
- Practice designing repository interfaces
- Experience the testability benefits of abstraction

**Hint**: Start with one entity (e.g., Users), refactor it completely, then move to the next.

## Key Takeaways

1. **Repository Pattern** abstracts data access behind an interface, improving testability and flexibility
2. **Active Record Pattern** combines domain objects with persistence logic for simplicity
3. **Choose patterns based on your needs**: Repository for complex domains, Active Record for rapid development
4. **Optimistic Locking** detects conflicts with version fields, ideal for rare conflicts
5. **Pessimistic Locking** prevents conflicts with exclusive locks, ideal for frequent conflicts
6. **Data layer patterns build on SOLID**: Dependency Inversion (depend on interfaces), Single Responsibility (separate persistence from business logic)

## Interactive Quiz

<quizdown id="data-layer-patterns-quiz">
<script type="module">
import { rawQuizdown } from '/src/quizzes/chapter-11/11.2.2/data-layer-patterns-quiz.js';
const prepareQuizdown = async () => {
  const quizdown = (await import('https://cdn.jsdelivr.net/gh/bonartm/quizdown-js@2.1.0/public/build/quizdown.js')).default;
  await quizdown.init();
  quizdown.register(rawQuizdown);
};
prepareQuizdown();
</script>
</quizdown>

## Additional Resources

- [Repository Pattern - Martin Fowler](https://martinfowler.com/eaaCatalog/repository.html)
- [Active Record Pattern - Martin Fowler](https://martinfowler.com/eaaCatalog/activeRecord.html)
- [Optimistic vs Pessimistic Locking](https://www.postgresql.org/docs/current/mvcc-intro.html)
- **"Patterns of Enterprise Application Architecture"** by Martin Fowler - Comprehensive coverage of data patterns
- Working examples in this repository:
  - [\`examples/ch11/data-patterns/repository/\`](/examples/ch11/data-patterns/repository/)
  - [\`examples/ch11/data-patterns/active-record/\`](/examples/ch11/data-patterns/active-record/)
  - [\`examples/ch11/data-patterns/concurrency/optimistic/\`](/examples/ch11/data-patterns/concurrency/optimistic/)
  - [\`examples/ch11/data-patterns/concurrency/pessimistic/\`](/examples/ch11/data-patterns/concurrency/pessimistic/)

## Next Steps

Now that you understand data layer patterns, you're ready to explore:

- **Business Logic Patterns** (11.2.3) - Transaction Script vs Domain Model
- **Classical Design Patterns** (11.2.4) - Strategy, Factory, Observer, Decorator
- **Pattern Application** (11.2.5) - Comprehensive refactoring exercise

Continue building your pattern recognition skills to become more effective at reading, understanding, and improving production codebases!

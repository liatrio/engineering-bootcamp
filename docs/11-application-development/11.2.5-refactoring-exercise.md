---
docs/11-application-development/11.2.5-refactoring-exercise.md:
  category: Software Development
  estReadingMinutes: 20
  exercises:
    -
      name: Integrated Refactoring Exercise
      description: Refactor an e-commerce application using Repository Pattern, Service Layer, and Strategy Pattern while preserving all business behavior through comprehensive testing.
      estMinutes: 180
      technologies:
      - TypeScript
      - Design Patterns
      - SQLite
---

# Integrated Refactoring Exercise

## Overview

This comprehensive refactoring exercise synthesizes the design patterns you've learned in sections 11.2.2-11.2.4. You'll transform a poorly-structured e-commerce order processing system into a clean, maintainable application using:

- **Repository Pattern** (from 11.2.2) - Abstracts data access
- **Service Layer** (from 11.2.3) - Organizes business logic
- **Strategy Pattern** (from 11.2.4) - Eliminates conditional logic
- **SOLID Principles** (from 11.2.1) - Guides all design decisions

The unique aspect of this exercise is that **all tests must pass before and after refactoring** without modification. This proves you've preserved business behavior while improving code quality.

## Learning Objectives

By the end of this exercise, you will be able to:

1. **Identify SOLID violations** in production-like code with specific examples
2. **Apply multiple patterns together** to solve real architectural problems
3. **Refactor safely** using behavior-preserving tests as validation
4. **Measure improvement** using concrete metrics (lines of code, file count, extensibility)
5. **Understand trade-offs** between simplicity and flexibility in design

## Prerequisites

Before starting this exercise, you should have completed:

- [11.2.1 SOLID Principles](/11-application-development/11.2.1-solid-principles.md) - Understanding of SRP, OCP, DIP
- [11.2.2 Data Layer Patterns](/11-application-development/11.2.2-data-layer-patterns.md) - Repository Pattern
- [11.2.3 Business Logic Patterns](/11-application-development/11.2.3-business-logic-patterns.md) - Service Layer
- [11.2.4 Classical Patterns](/11-application-development/11.2.4-classical-patterns.md) - Strategy Pattern

You'll also need:

- Node.js 18+ and npm installed
- SQLite3 (pre-installed on macOS/Linux)
- Basic TypeScript knowledge
- Understanding of Express.js (helpful but not required)

## The Domain: E-Commerce Order Processing

The application is a simple e-commerce order processing system that handles:

### Entities

- **Products** - Items available for purchase (laptops, mice, keyboards, etc.)
- **Customers** - Users who place orders
- **Orders** - Customer purchases containing multiple items
- **OrderItems** - Individual line items in an order

### Business Rules

- **Payment Processing**: Three payment types supported
  - Credit Card: 3% processing fee
  - PayPal: 3.5% processing fee
  - Bitcoin: $1.50 flat fee
  
- **Shipping Calculation**: Three shipping methods supported
  - Standard: $5.99, 7-day delivery
  - Express: $12.99, 3-day delivery
  - Overnight: $24.99, 1-day delivery

- **Inventory Management**: Stock automatically decrements after successful orders

### Current Architecture (Starter)

The starter application is deliberately designed with anti-patterns:

```
Client ‚Üí routes.ts (450 lines - GOD OBJECT) ‚Üí SQLite
         ‚Üì
    Everything happens here:
    - Input validation
    - Customer verification
    - Inventory checking
    - Payment fee calculation (if/else chains)
    - Shipping cost calculation (if/else chains)
    - Database operations
    - Stock decrement
    - Response formatting
```

**Problems:**
- 450+ lines in a single file
- 7+ reasons to change (violates SRP)
- if/else chains for payment/shipping (violates OCP)
- Direct database access (violates DIP)
- Cannot test without Express + SQLite
- Cannot extend without modification

## Phase 1: Code Analysis

**Time Estimate:** 30-45 minutes

### Task 1.1: Set Up the Starter Application

```bash
cd examples/ch11/refactoring-exercise/starter
npm install
npm run db:reset
npm test
```

All 37 tests should pass. These tests validate business behavior and will be your safety net during refactoring.

### Task 1.2: Complete the Analysis Guide

Open `../analysis-guide.md` and work through each section:

1. **Collect Baseline Metrics**
   ```bash
   wc -l src/routes.ts          # Count lines
   find src -type f | wc -l     # Count files
   ```

2. **Identify SOLID Violations**
   - Find all 7+ reasons routes.ts might change
   - Test OCP: Try adding Apple Pay (how many files must change?)
   - Identify DIP violations (direct database dependencies)

3. **Locate Code Smells**
   - God Object (routes.ts)
   - Type Code (if/else chains for payment/shipping)
   - Long Method (POST /orders handler ~285 lines)

4. **Document Specific Line Numbers**
   Record violations in analysis guide with exact line numbers:
   - Validation logic: lines 28-68
   - Payment calculation: lines 144-172
   - Shipping calculation: lines 176-214
   - etc.

**Deliverable:** Completed analysis guide with metrics and line numbers

### Task 1.3: Draw Current Architecture Diagram

On paper or whiteboard, draw the current architecture showing:
- HTTP layer (routes.ts)
- Direct database access
- Mixed concerns (no separation)

**Question to Answer:** What's missing from a proper layered architecture?

### Task 1.4: Plan the Extension Test

Document what changes would be required to add Apple Pay (4% fee):

Current approach requires modifying:
1. \_\_\_\_\_\_\_\_\_ (file)
2. \_\_\_\_\_\_\_\_\_ (file)
3. \_\_\_\_\_\_\_\_\_ (file)

After refactoring, should only require: **1 new file**

**Deliverable:** Written analysis documenting current state

---

## Phase 2: Planning Your Refactoring

**Time Estimate:** 30-45 minutes

### Task 2.1: Define Interfaces

Before coding, design the interfaces you'll need:

**Payment Strategy Interface:**
```typescript
interface IPaymentStrategy {
  calculateFee(subtotal: number): number;
  getType(): string;
}
```

**Shipping Strategy Interface:**
```typescript
interface IShippingStrategy {
  calculateCost(): number;
  getDeliveryDays(): number;
  getMethod(): string;
}
```

**Product Repository Interface:**
```typescript
interface IProductRepository {
  findById(id: number): Promise<Product | null>;
  updateStock(id: number, quantityChange: number): Promise<void>;
  checkStock(id: number, quantity: number): Promise<boolean>;
}
```

**Order Repository Interface:**
```typescript
interface IOrderRepository {
  create(orderData: Omit<Order, 'id' | 'created_at'>): Promise<number>;
  addItems(orderId: number, items: Omit<OrderItem, 'id' | 'order_id'>[]): Promise<void>;
  findById(id: number): Promise<Order | null>;
  // ... other methods
}
```

**Deliverable:** Interface definitions written down

### Task 2.2: Plan Refactoring Order

Strategy Pattern is independent and easiest to test, so start there:

1. **Strategies First** (payment & shipping)
   - Can be developed and tested independently
   - Quick wins to build confidence
   - Eliminates if/else chains immediately

2. **Repositories Second** (data access)
   - Requires interfaces defined
   - Abstracts database operations
   - Enables dependency injection

3. **Services Third** (business logic)
   - Depends on repositories and strategies
   - Orchestrates workflow
   - Separates from HTTP concerns

4. **Routes Last** (HTTP layer)
   - Becomes thin delegation layer
   - Depends on services
   - Minimal logic remaining

**Deliverable:** Written implementation plan

### Task 2.3: Set Up Directory Structure

```bash
mkdir -p src/strategies/{payment,shipping}
mkdir -p src/repositories
mkdir -p src/services
mkdir -p src/factories
mkdir -p src/routes
mkdir -p src/domain
```

**Checkpoint:** Run `npm test` - all tests should still pass

---

## Phase 3: Implementation

**Time Estimate:** 90-120 minutes

### Task 3.1: Implement Payment Strategies

Create three payment strategy classes:

**src/strategies/payment/CreditCardPayment.ts:**
```typescript
import { IPaymentStrategy } from './IPaymentStrategy';

export class CreditCardPayment implements IPaymentStrategy {
  calculateFee(subtotal: number): number {
    return Math.round(subtotal * 0.03 * 100) / 100;
  }
  getType(): string {
    return 'credit_card';
  }
}
```

Similarly create `PayPalPayment.ts` (3.5%) and `BitcoinPayment.ts` ($1.50 flat).

**Test Your Progress:**
```typescript
const strategy = new CreditCardPayment();
console.log(strategy.calculateFee(100)); // Should be 3.00
```

### Task 3.2: Implement Shipping Strategies

Create three shipping strategy classes in `src/strategies/shipping/`:
- `StandardShipping.ts` - $5.99, 7 days
- `ExpressShipping.ts` - $12.99, 3 days
- `OvernightShipping.ts` - $24.99, 1 day

### Task 3.3: Create Strategy Factories

**src/factories/PaymentStrategyFactory.ts:**
```typescript
import { IPaymentStrategy } from '../strategies/payment/IPaymentStrategy';
import { CreditCardPayment } from '../strategies/payment/CreditCardPayment';
// ... other imports

export class PaymentStrategyFactory {
  private strategies = new Map<string, () => IPaymentStrategy>();

  constructor() {
    this.registerStrategy('credit_card', () => new CreditCardPayment());
    this.registerStrategy('paypal', () => new PayPalPayment());
    this.registerStrategy('bitcoin', () => new BitcoinPayment());
  }

  registerStrategy(type: string, factory: () => IPaymentStrategy): void {
    this.strategies.set(type, factory);
  }

  getStrategy(type: string): IPaymentStrategy {
    const factory = this.strategies.get(type);
    if (!factory) {
      throw new Error(`Unsupported payment type: ${type}`);
    }
    return factory();
  }
}
```

Create similar `ShippingStrategyFactory.ts`.

**Checkpoint:** Factories can create all strategies

### Task 3.4: Implement Repository Pattern

**src/repositories/ProductRepository.ts:**
```typescript
import { IProductRepository } from './IProductRepository';
import { dbGet, dbRun } from '../database';

export class ProductRepository implements IProductRepository {
  async findById(id: number): Promise<Product | null> {
    return await dbGet<Product>(
      'SELECT * FROM products WHERE id = ?',
      [id]
    ) || null;
  }

  async updateStock(id: number, quantityChange: number): Promise<void> {
    const product = await this.findById(id);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }
    
    const newStock = product.stock_quantity + quantityChange;
    if (newStock < 0) {
      throw new Error(`Insufficient stock for product ${product.name}`);
    }

    await dbRun(
      'UPDATE products SET stock_quantity = ? WHERE id = ?',
      [newStock, id]
    );
  }
  
  // ... implement checkStock
}
```

Similarly implement `OrderRepository.ts`.

**Checkpoint:** Repositories encapsulate all database operations

### Task 3.5: Implement Service Layer

**src/services/ValidationService.ts** - Handle all input validation
**src/services/InventoryService.ts** - Manage stock checking and updates
**src/services/OrderService.ts** - Orchestrate order creation workflow

**Example OrderService structure:**
```typescript
export class OrderService {
  constructor(
    private orderRepository: IOrderRepository,
    private productRepository: IProductRepository,
    private paymentFactory: PaymentStrategyFactory,
    private shippingFactory: ShippingStrategyFactory,
    private validationService: ValidationService,
    private inventoryService: InventoryService
  ) {}

  async createOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    // 1. Validate
    this.validationService.validateOrderRequest(request);
    
    // 2. Check inventory
    await this.inventoryService.checkAvailability(request.items);
    
    // 3. Calculate fees using strategies
    const paymentStrategy = this.paymentFactory.getStrategy(request.payment_type);
    const paymentFee = paymentStrategy.calculateFee(subtotal);
    
    // 4. Create order via repository
    const orderId = await this.orderRepository.create({...});
    
    // 5. Return response
    return { order_id: orderId, ... };
  }
}
```

**Checkpoint:** Business logic separated from HTTP and data access

### Task 3.6: Create Thin HTTP Layer

**src/routes/orderRoutes.ts:**
```typescript
export function createOrderRoutes(
  orderService: OrderService,
  orderRepository: IOrderRepository,
  productRepository: IProductRepository
): Router {
  const router = Router();

  router.post('/orders', async (req: Request, res: Response) => {
    try {
      const result = await orderService.createOrder(req.body);
      return res.status(201).json(result);
    } catch (error) {
      // Error handling
    }
  });

  // ... other routes
  
  return router;
}
```

**Goal:** Routes should be < 50 lines total, mostly delegation

### Task 3.7: Wire Dependency Injection

**src/index.ts:**
```typescript
// Create repositories
const orderRepository = new OrderRepository();
const productRepository = new ProductRepository();

// Create factories
const paymentFactory = new PaymentStrategyFactory();
const shippingFactory = new ShippingStrategyFactory();

// Create services
const validationService = new ValidationService();
const inventoryService = new InventoryService(productRepository);
const orderService = new OrderService(
  orderRepository,
  productRepository,
  paymentFactory,
  shippingFactory,
  validationService,
  inventoryService
);

// Create routes
const orderRoutes = createOrderRoutes(orderService, orderRepository, productRepository);
app.use('/api', orderRoutes);
```

**Checkpoint:** Run `npm test` - **all 37 tests should still pass!**

---

## Phase 4: Verification

**Time Estimate:** 15-30 minutes

### Task 4.1: Verify Behavior Preservation

```bash
npm test
```

**Expected:** All 37 tests pass without modification

If tests fail:
1. Review error messages carefully
2. Check you haven't changed business logic
3. Ensure calculations match original (rounding, decimals)
4. Verify database operations are correct

### Task 4.2: Collect "After" Metrics

```bash
wc -l src/routes/orderRoutes.ts  # Should be < 150
find src -type f -name "*.ts" | wc -l  # Should be 15-20+
```

Compare with baseline metrics from Phase 1.

### Task 4.3: Test Open/Closed Principle

Try adding Apple Pay (4% fee):

1. Create `src/strategies/payment/ApplePayPayment.ts`:
   ```typescript
   export class ApplePayPayment implements IPaymentStrategy {
     calculateFee(subtotal: number): number {
       return Math.round(subtotal * 0.04 * 100) / 100;
     }
     getType(): string {
       return 'apple_pay';
     }
   }
   ```

2. Register in factory (one line):
   ```typescript
   paymentFactory.registerStrategy('apple_pay', () => new ApplePayPayment());
   ```

3. No other files should need modification!

**Success Criteria:** Added new payment type by creating 1 file and modifying 1 line

### Task 4.4: Test Dependency Inversion

Can you unit test `OrderService` without a database?

```typescript
// Create mock repository
class MockProductRepository implements IProductRepository {
  async findById(id: number): Promise<Product | null> {
    return { id, name: 'Test Product', price: 10.00, stock_quantity: 100 };
  }
  // ... mock other methods
}

// Test with mock
const mockProductRepo = new MockProductRepository();
const service = new OrderService(
  mockOrderRepo,
  mockProductRepo,
  paymentFactory,
  shippingFactory,
  validationService,
  new InventoryService(mockProductRepo)
);

// Now you can test business logic without database!
```

**Success Criteria:** Can test services independently with mocks

---

## Phase 5: Comparing Solutions

**Time Estimate:** 15-30 minutes

### Task 5.1: Review Reference Solution

Explore the reference solution in `../solution/`:

```bash
cd ../solution
npm install
npm run db:reset
npm test
```

All tests pass here too!

### Task 5.2: Compare Architectures

Draw "After" architecture diagram showing:

```
Client ‚Üí HTTP Layer (routes)
              ‚Üì
         Service Layer (OrderService)
              ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì                  ‚Üì
Strategies      Repositories
(Payment,         (Order,
 Shipping)        Product)
    ‚Üì                  ‚Üì
  [Algorithms]    [SQLite]
```

Compare with your "Before" diagram from Phase 1.

### Task 5.3: Compare Key Files

**routes.ts: Before vs After**

Before:
- 450+ lines
- All logic mixed together
- 7+ responsibilities

After:
- < 150 lines total across focused files
- Clear separation of concerns
- Each file has 1 responsibility

**Adding Apple Pay: Before vs After**

Before:
- Modify routes.ts (lines 144-172)
- Modify types.ts
- Modify validation logic

After:
- Create 1 new file (ApplePayPayment.ts)
- Register in factory (1 line)

### Task 5.4: Review Metrics

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Lines in main handler | ~285 | ~15 | 95% reduction |
| Files in codebase | 4 | 20+ | Better organization |
| To add payment type | 3 files | 1 file | 67% less coupling |
| Can unit test logic | No | Yes | Testable |
| SOLID violations | 5+ major | 0 | Compliant |

**Deliverable:** Completed metrics comparison table

---

## Git Workflow

Track your refactoring progress with meaningful commits:

### Recommended Commit Strategy

```bash
# After each major phase
git add .
git commit -m "refactor: Add Strategy Pattern for payment processing

- Created IPaymentStrategy interface
- Implemented CreditCardPayment, PayPalPayment, BitcoinPayment
- Eliminates if/else chain (OCP)
- All tests still pass"
```

### Suggested Commits

1. "refactor: Add Strategy Pattern for payment and shipping"
2. "refactor: Add Repository Pattern for data access"
3. "refactor: Add Service Layer for business logic"
4. "refactor: Create thin HTTP layer with dependency injection"
5. "test: Verify all tests pass with refactored code"
6. "docs: Add architecture diagrams and metrics"

### Commit Message Template

```
refactor: [Brief description]

- [SOLID principle applied]: [How]
- [Pattern introduced]: [Why]
- [Benefit]: [What improved]
- Tests: [Status]
```

---

## Success Criteria

Your refactored solution is successful when:

### Functional Requirements

- [ ] All 37 tests pass without modification
- [ ] Can create orders with same API
- [ ] Payment fees calculate correctly
- [ ] Shipping costs calculate correctly
- [ ] Inventory management works correctly

### Architecture Requirements

- [ ] Main HTTP handler < 50 lines
- [ ] No if/else chains for payment/shipping types
- [ ] Business logic separated from HTTP layer
- [ ] Data access separated into repositories
- [ ] Each class follows SRP (one responsibility)

### Extensibility Requirements

- [ ] Can add Apple Pay by creating ONE file
- [ ] Can swap SQLite for PostgreSQL by implementing interface
- [ ] Can test OrderService without database (using mocks)

### Code Quality Requirements

- [ ] All SOLID principles followed
- [ ] Clear separation of concerns
- [ ] Dependencies injected, not hard-coded
- [ ] Interfaces define contracts
- [ ] No God Objects remaining

---

## Reflection Questions

After completing the exercise, reflect on these questions:

### 1. Code Quality Impact

**Before vs After:** Rate the refactored code on a scale of 1-10 for:
- Understandability: ___
- Maintainability: ___
- Testability: ___
- Extensibility: ___

What specific changes improved these qualities?

### 2. Trade-Offs

**Complexity:** You now have 20+ files instead of 4. 

- Is this increased complexity justified?
- When would you NOT want to refactor this way?
- What's the "right" level of abstraction for different project sizes?

### 3. Real-World Applications
**Your Codebase:** Think of a class/module in your work codebase.

- Does it have multiple responsibilities?
- Does it have if/else chains for types?
- Could Strategy or Repository Pattern help?
- What would prevent you from refactoring it?

### 4. Pattern Selection
**Decision Making:** How do you know when to apply each pattern?

- When is Strategy Pattern better than if/else?
- When is Repository Pattern overkill?
- When should you use Service Layer?

### 5. Testing Impact
**Behavior Preservation:** How did tests help during refactoring?

- Did tests catch breaking changes?
- Were tests granular enough?
- What additional tests would you write?

**Deliverable:** Written reflection (1-2 paragraphs per question)

---

## Additional Challenges

Want to go further? Try these extensions:

### Challenge 1: Add Discount System

Add a discount strategy system:
- **VolumeDiscount**: 10% off orders > $500
- **LoyaltyDiscount**: 5% off for returning customers
- **PromoCodeDiscount**: Variable % based on code

Requirements:
- Use Strategy Pattern
- Can apply multiple discounts
- Tests must pass

### Challenge 2: Add Event Notifications

Add Observer Pattern for order events:
- **EmailNotifier**: Sends confirmation email
- **InventoryNotifier**: Alerts when stock low
- **AnalyticsNotifier**: Tracks order metrics

Requirements:
- Orders notify observers on status changes
- Observers are loosely coupled
- Can add/remove observers dynamically

### Challenge 3: Swap to PostgreSQL

Replace SQLite with PostgreSQL:
- Create `PostgresProductRepository`
- Create `PostgresOrderRepository`
- Update dependency injection
- All tests should still pass

Requirements:
- Only repository implementations change
- Services don't change
- Routes don't change

### Challenge 4: Add API Versioning

Support `/api/v2/orders` with enhanced response format:
- Reuse existing `OrderService`
- Different response serialization
- Backward compatibility with v1

Requirements:
- No duplication of business logic
- Both versions use same service
- Clean separation of concerns

---

## Common Pitfalls to Avoid

### 1. Changing Test Files
**DON'T** modify the test files. They validate behavior preservation. If tests fail:
- Fix your implementation, not the tests
- Tests catching bugs is good - they're working correctly

### 2. Over-Engineering
**DON'T** add unnecessary abstraction:
- Keep it simple and focused
- Don't create interfaces you don't need
- Educational code != enterprise production code

### 3. Premature Optimization
**DON'T** focus on performance:
- Focus on patterns and principles
- Readability > Performance for this exercise
- Measure first, optimize later (not needed here)

### 4. Skipping Interfaces
**DON'T** skip defining interfaces:
- Interfaces enable Dependency Inversion
- Interfaces make testing possible
- Interfaces document contracts

### 5. Forgetting Dependency Injection
**DON'T** create dependencies inside classes:
```typescript
// BAD
class OrderService {
  private repository = new OrderRepository(); // Hard-coded!
}

// GOOD
class OrderService {
  constructor(private repository: IOrderRepository) {} // Injected!
}
```

### 6. Making It Too Complex
**DON'T** add features or change behavior:
- This is refactoring, not feature development
- Focus on structure, not functionality
- Tests define the behavior boundary

---

## Additional Resources

### Design Patterns
- [Refactoring Guru - Strategy Pattern](https://refactoring.guru/design-patterns/strategy)
- [Refactoring Guru - Repository Pattern](https://refactoring.guru/design-patterns/repository)
- [Martin Fowler - Service Layer](https://martinfowler.com/eaaCatalog/serviceLayer.html)

### SOLID Principles
- [Uncle Bob - SOLID Principles](https://www.youtube.com/watch?v=TMuno5RZNeE)
- [Clean Code by Robert C. Martin](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)

### Refactoring
- [Refactoring by Martin Fowler](https://refactoring.com/)
- [Working Effectively with Legacy Code by Michael Feathers](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)

### Within This Bootcamp
- [11.2.1 SOLID Principles](/11-application-development/11.2.1-solid-principles.md)
- [11.2.2 Data Layer Patterns](/11-application-development/11.2.2-data-layer-patterns.md)
- [11.2.3 Business Logic Patterns](/11-application-development/11.2.3-business-logic-patterns.md)
- [11.2.4 Classical Patterns](/11-application-development/11.2.4-classical-patterns.md)

---

## Summary

This exercise demonstrated how design patterns work together to create maintainable, extensible software:

- **Strategy Pattern** eliminated if/else chains and enabled extension
- **Repository Pattern** abstracted data access and enabled testing
- **Service Layer** separated business logic from infrastructure
- **Dependency Injection** made everything flexible and testable
- **SOLID Principles** guided every design decision

Most importantly, you proved behavior preservation through comprehensive testing. This is the key to safe refactoring in production environments.

The skills you've practiced here‚Äîidentifying violations, applying patterns, measuring improvement, and preserving behavior‚Äîare directly applicable to real-world software development. Use them wisely!

---

## Next Steps

1. **Practice Identifying Patterns** - Look for Strategy, Repository, and Service Layer patterns in open-source projects
2. **Apply to Your Code** - Find a God Object in your codebase and plan a refactoring
3. **Continue Learning** - Explore additional GoF patterns (Builder, Adapter, Facade)
4. **Share Your Learning** - Help others understand these patterns by explaining them

Remember: Good design is iterative. Start simple, refactor when complexity grows, and always let tests guide you.

Happy refactoring! üöÄ
